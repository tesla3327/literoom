# Implementation Plan: WASM Bindings for Image Decoding

**Date**: 2026-01-20
**Status**: Complete - All Phases Done
**Research**: [WASM Bindings Synthesis](../research/2026-01-20-wasm-bindings-synthesis.md)
**Parent Plan**: [Image Decoding Plan](./2026-01-20-image-decoding-plan.md) (Phase 6)
**Priority**: Critical (enables TypeScript integration)

## Objective

Create WASM bindings for the literoom-core image decoding pipeline, exposing JPEG decoding, RAW thumbnail extraction, and resize operations to JavaScript/TypeScript via wasm-bindgen.

---

## Key Design Decisions (from research)

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Pixel buffer transfer | `Vec<u8>` returns (copy) | Safe, simple; copy overhead acceptable vs decode time |
| Input handling | `&[u8]` from JS | Zero-copy view into JS memory |
| Memory management | wasm-bindgen automatic | Finalizers handle cleanup; `.free()` available |
| Error handling | `Result<T, JsValue>` with strings | Consistent with existing patterns |
| TypeScript types | Auto-generated by wasm-bindgen | No manual maintenance |
| Build target | `wasm-pack --target web` | Works in browsers and with bundlers |
| Output location | `packages/wasm/` | Consumed by `@literoom/core` |

---

## Implementation Phases

### Phase 1: File Organization (Refactor existing code)

**Goal**: Organize literoom-wasm into a clean module structure.

#### Tasks

- [x] 1.1. Create `crates/literoom-wasm/src/adjustments.rs`
  - Move `BasicAdjustments` wrapper from `lib.rs`
  - Keep existing getter/setter pattern

- [x] 1.2. Create `crates/literoom-wasm/src/types.rs`
  - Add `JsDecodedImage` struct
  - Add `JsImageMetadata` struct (optional, for future use)

- [x] 1.3. Update `crates/literoom-wasm/src/lib.rs`
  - Add module declarations for `adjustments`, `types`, `decode`
  - Re-export public types
  - Keep init and version functions

#### File Structure (Target)

```
crates/literoom-wasm/src/
├── lib.rs              # Module exports, init, version
├── adjustments.rs      # BasicAdjustments wrapper (moved from lib.rs)
├── types.rs            # JsDecodedImage, JsImageMetadata
└── decode.rs           # Decode function bindings
```

---

### Phase 2: Core Types (types.rs)

**Goal**: Create WASM-compatible wrapper types for image data.

#### Tasks

- [x] 2.1. Implement `JsDecodedImage`

```rust
#[wasm_bindgen]
pub struct JsDecodedImage {
    width: u32,
    height: u32,
    pixels: Vec<u8>,  // RGB format
}

#[wasm_bindgen]
impl JsDecodedImage {
    #[wasm_bindgen(getter)]
    pub fn width(&self) -> u32;

    #[wasm_bindgen(getter)]
    pub fn height(&self) -> u32;

    /// Returns RGB pixel data as Uint8Array (creates copy)
    pub fn pixels(&self) -> Vec<u8>;

    /// Get the number of bytes in the pixel buffer
    #[wasm_bindgen(getter)]
    pub fn byte_length(&self) -> usize;

    /// Explicitly free WASM memory (optional - finalizer handles this)
    pub fn free(self);
}
```

- [x] 2.2. Add internal constructor for `JsDecodedImage`

```rust
impl JsDecodedImage {
    pub(crate) fn from_decoded(img: DecodedImage) -> Self {
        Self {
            width: img.width,
            height: img.height,
            pixels: img.pixels,
        }
    }
}
```

---

### Phase 3: Decode Bindings (decode.rs)

**Goal**: Expose decode functions to JavaScript.

#### Tasks

- [x] 3.1. Implement `decode_jpeg`

```rust
#[wasm_bindgen]
pub fn decode_jpeg(bytes: &[u8]) -> Result<JsDecodedImage, JsValue> {
    literoom_core::decode::decode_jpeg(bytes)
        .map(JsDecodedImage::from_decoded)
        .map_err(|e| JsValue::from_str(&e.to_string()))
}
```

- [x] 3.2. Implement `extract_raw_thumbnail_bytes`

```rust
#[wasm_bindgen]
pub fn extract_raw_thumbnail_bytes(bytes: &[u8]) -> Result<Vec<u8>, JsValue> {
    literoom_core::decode::extract_raw_thumbnail(bytes)
        .map_err(|e| JsValue::from_str(&e.to_string()))
}
```

- [x] 3.3. Implement `decode_raw_thumbnail`

```rust
#[wasm_bindgen]
pub fn decode_raw_thumbnail(bytes: &[u8]) -> Result<JsDecodedImage, JsValue> {
    literoom_core::decode::decode_raw_thumbnail(bytes)
        .map(JsDecodedImage::from_decoded)
        .map_err(|e| JsValue::from_str(&e.to_string()))
}
```

- [x] 3.4. Implement `is_raw_file`

```rust
#[wasm_bindgen]
pub fn is_raw_file(bytes: &[u8]) -> bool {
    literoom_core::decode::is_raw_file(bytes)
}
```

- [x] 3.5. Implement `resize`

```rust
#[wasm_bindgen]
pub fn resize(
    image: &JsDecodedImage,
    width: u32,
    height: u32,
    filter: u8,  // 0=Nearest, 1=Bilinear, 2=Lanczos3
) -> Result<JsDecodedImage, JsValue> {
    // Convert to core type, resize, convert back
}
```

- [x] 3.6. Implement `resize_to_fit`

```rust
#[wasm_bindgen]
pub fn resize_to_fit(
    image: &JsDecodedImage,
    max_edge: u32,
    filter: u8,
) -> Result<JsDecodedImage, JsValue>
```

- [x] 3.7. Implement `generate_thumbnail`

```rust
#[wasm_bindgen]
pub fn generate_thumbnail(
    image: &JsDecodedImage,
    size: u32,
) -> Result<JsDecodedImage, JsValue>
```

- [x] 3.8. Add helper function for filter conversion (in types.rs)

```rust
fn filter_from_u8(value: u8) -> literoom_core::decode::FilterType {
    match value {
        0 => FilterType::Nearest,
        2 => FilterType::Lanczos3,
        _ => FilterType::Bilinear,  // Default
    }
}
```

---

### Phase 4: Build Configuration

**Goal**: Configure wasm-pack and add build scripts.

#### Tasks

- [x] 4.1. Verify `Cargo.toml` WASM configuration

Existing configuration is correct:
```toml
[profile.release]
opt-level = "s"
lto = true
```

- [x] 4.2. Add wasm-pack build scripts to root `package.json`

Scripts already exist:
```json
{
  "scripts": {
    "wasm:build": "wasm-pack build crates/literoom-wasm --target web --out-dir ../../packages/wasm",
    "wasm:build:dev": "wasm-pack build crates/literoom-wasm --target web --dev --out-dir ../../packages/wasm"
  }
}
```

- [x] 4.3. Create `packages/wasm/.gitignore`

Created to ignore generated files:
```gitignore
# Generated by wasm-pack - do not commit
*.wasm
*.js
*.d.ts
package.json
```

- [x] 4.4. Run initial build and verify output

Build successful! Output files in `packages/wasm/`:
- `literoom_wasm.js` - ES module wrapper (31KB)
- `literoom_wasm.d.ts` - TypeScript definitions (13KB)
- `literoom_wasm_bg.wasm` - WASM binary (447KB)
- `literoom_wasm_bg.wasm.d.ts` - WASM types (3KB)
- `package.json` - Generated package manifest

---

### Phase 5: Testing

**Goal**: Ensure bindings work correctly.

#### Tasks

- [x] 5.1. Add unit tests for types

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_js_decoded_image_creation() {
        let img = JsDecodedImage {
            width: 100,
            height: 50,
            pixels: vec![0u8; 100 * 50 * 3],
        };
        assert_eq!(img.width(), 100);
        assert_eq!(img.height(), 50);
        assert_eq!(img.byte_length(), 15000);
    }
}
```

- [x] 5.2. Add wasm-bindgen-test for WASM environment (optional)

```rust
#[cfg(target_arch = "wasm32")]
#[cfg(test)]
mod wasm_tests {
    use wasm_bindgen_test::*;

    wasm_bindgen_test_configure!(run_in_browser);

    #[wasm_bindgen_test]
    fn test_decode_invalid_jpeg() {
        let result = super::decode_jpeg(&[0, 1, 2, 3]);
        assert!(result.is_err());
    }
}
```

- [x] 5.3. Verify Rust tests still pass

```bash
cargo test --all-features
```

- [x] 5.4. Verify clippy passes

```bash
cargo clippy --all-targets -- -D warnings
```

- [x] 5.5. Verify formatting

```bash
cargo fmt --all -- --check
```

---

### Phase 6: CI Integration

**Goal**: Ensure WASM builds in CI.

#### Tasks

- [x] 6.1. Update `.github/workflows/ci.yml` WASM job

The existing CI workflow has a WASM build step. Verify it:
- Uses `wasm-pack build` with correct arguments
- Outputs to `packages/wasm/`
- Runs after Rust checks pass

---

## Verification Checklist

After implementation:

- [x] `cargo check --all-targets` passes
- [x] `cargo clippy --all-targets -- -D warnings` passes
- [x] `cargo fmt --all -- --check` passes
- [x] `cargo test --all-features` passes (all existing + new tests) - 65 tests (50 core + 15 wasm)
- [x] `pnpm wasm:build` produces output in `packages/wasm/`
- [x] Generated `.d.ts` files contain expected type definitions
- [x] WASM binary size is reasonable (<2MB for release build) - 447KB

---

## Expected TypeScript API (post-build)

```typescript
import init, {
  decode_jpeg,
  extract_raw_thumbnail_bytes,
  decode_raw_thumbnail,
  is_raw_file,
  resize,
  resize_to_fit,
  generate_thumbnail,
  JsDecodedImage
} from '@literoom/wasm';

// Initialize WASM module (must call first)
await init();

// Decode JPEG
const fileBytes = new Uint8Array(await file.arrayBuffer());
const image: JsDecodedImage = decode_jpeg(fileBytes);
console.log(`Decoded ${image.width}x${image.height}`);

// Check if RAW file
if (is_raw_file(fileBytes)) {
  const thumbnail = decode_raw_thumbnail(fileBytes);
}

// Resize for preview
const preview = resize_to_fit(image, 2560, 2); // Lanczos3

// Generate grid thumbnail
const thumb = generate_thumbnail(image, 256);

// Get pixels for canvas rendering
const pixels: Uint8Array = thumb.pixels();

// Optional: explicit cleanup
image.free();
```

---

## Next Steps (after this plan)

1. **Phase 7 of Image Decoding Plan**: TypeScript Integration
   - Create `DecodeService` class
   - Implement Web Worker wrapper
   - Add decode worker with WASM initialization

2. **Phase 4 of Image Decoding Plan**: Full RAW Decoding
   - Implement demosaicing
   - Add color space conversion
   - Expose via WASM bindings

---

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| WASM bundle too large | Already using `opt-level = "s"` and LTO; can strip debug info |
| Memory issues with large images | One-image-at-a-time processing; worker isolation |
| Browser compatibility | Target `web` works in all modern browsers |
| Type generation issues | wasm-bindgen is mature; fallback to manual types if needed |

---

## Implementation Notes

- Keep functions stateless where possible (easier to reason about memory)
- Use references (`&JsDecodedImage`) for read-only operations
- Document any functions that consume the input image
- JSDoc comments become TypeScript documentation
